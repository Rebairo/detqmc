//Code by Max Henner Gerlach, 2010--2012,
//used for the diploma thesis "Directional Ordering in the Classical Compass Model in Two and Three Dimensions"
//contact: maxgerlach@gmail.com

/*
 * mrpt-highlevel.cpp
 *
 *  Created on: Aug 5, 2011
 *      Author: max
 */

// generalized for SDW DQMC (2015-02-06 - )

#include <iostream>
#include <fstream>
#include <exception>
#include <map>
#include <memory>               // shared_ptr
#include <array>
#include <string>
#include "metadata.h"
#include "tools.h"
#include "statistics.h"
#include "datamapwriter.h"
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wshadow"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#include "dlib/cmd_line_parser.h" // for simplicity: keep using DLIB for this instead of rewriting the handling below with Boost
#include "boost/filesystem.hpp"
#pragma GCC diagnostic pop
#include "mrpt.h"
#include "mrpt-jk.h"
#include "mrpt-highlevel.h"

using namespace std;

//variables in the following anonymous namespace are local to this file
namespace {
    MultireweightHistosPT* mr = 0;

    enum BC { PBC=0, APBCX=1, APBCY=2, APBCXY=3, NONE };
    const std::array<BC, 4> all_BC = {{PBC, APBCX, APBCY, APBCXY}};
    std::array<std::shared_ptr<MultireweightHistosPT>, 4> mrbc;
    
    unsigned binCount = 0;
    bool discreteIsingBins = false;

    bool use_jackknife = false;
    unsigned jackknifeBlocks = 0;

    bool do_directEstimates = false;

    bool non_iterative = true;
    unsigned maxIterations = 10000;
    double iterationTolerance = 1E-7;

    bool be_quiet = false;
    ofstream dev_null("/dev/null");
    string outputDirPrefix;
    string infoFilename;

    std::array<std::string, 4> infoFilenamesBC;

    typedef dlib::cmd_line_parser<char>::check_1a_c clp;
    clp parser;

    unsigned subsampleHowMuch = 1;
    unsigned discardSamples = 0;
    bool sortByCp = false;
    bool saveTauInt = false;
    string zInFile;
    string zOutFile;

    bool globalTau = false;
    bool noTau = false;
    bool autocorrPlots = false;
    bool crossCorr = false;
    bool crossCorrAlt = false;

    string headerSuffix;

    enum { COL1, COL2 } timeSeriesFormat;
}



void initFromCommandLine(int argc, char** argv) {
    //Command line parsing
    parser.add_option("help", "display this help message");
    parser.add_option("q", "be less verbose");
    parser.add_option("info", "info generated by simulation (\"info.dat\")", 1);
    parser.add_option("b", "number of energy bins", 1);
    parser.add_option("discrete-ising-bins", "Pass this instead of -b to set up energy bins that match the natural discrete energies of the 2D Ising model of this system size.");
    parser.add_option("i", "max number of iterations to determine Z[cp]", 1);
    parser.add_option("t", "tolerance in iterative determination of Z[cp]", 1);
    parser.add_option("loadz", "load partition functions from the indicated file", 1);
    parser.add_option("savez", "save partition functions to the indicated file", 1);

    parser.add_option("direct", "also calculate direct averages from the time series at the original temperatures without any reweighting");

    parser.add_option("non-iterative", "first do a non-iterative estimation of the density of states as in Fenwick, 2008");

    parser.add_option("constant-overlap", "iteratively reweight energy histograms until constant overlap is achieved");
    parser.add_option("n", "indicates number of target temperatures if --constant-overlap is passed. Default: same as input.", 1);

    parser.add_option("cp-range", "Takes three arguments to determine the range of control parameters to reweight to: the minimum, the maximum and the step size", 3);
    parser.add_option("cp-auto-range", "Takes one argument to determine the control parameter to reweight to: the step size; minimum and maximum are determinded automatically", 1);    
    parser.add_option("cp-range-discrete", "Takes three arguments to determine the range of inverse temperatures to discretely reweight energy and heat capacity to: the minimum, the maximum and the step size", 3);
    parser.add_option("j", "use jack-knife error estimation, indicate number of blocks", 1);
    parser.add_option("h", "write reweighted histograms at each target cp");

    parser.add_option("max-susc", "Search the maximum of the observable susceptibiliy between the inverse temperatures given as arguments", 2);
    parser.add_option("min-binder", "Search the minimum of the binder cumulant of the observable between the inverse temperatures given as arguments", 2);
    parser.add_option("max-specific-heat", "Search the maximum of the specific heat between the inverse temperatures given as arguments", 2);
    parser.add_option("energy-double-peak", "Search equal-height and equal-weight double-peak energy histograms between the inverse temperatures given as arguments", 2);
    parser.add_option("obs-double-peak", "Search an equal-height and equal-weight double-peak observable histograms between the inverse temperatures given as arguments", 2);
    parser.add_option("peak-tolerance", "tolerance factor in determining dip in double-peak histograms. Default: 0.1", 1);

    parser.add_option("reldip-at", "Determine relative dips in histograms at given target cp", 1);

    parser.add_option("sub-sample", "Sub samples the time series as they are read in (pass number of data points to be put into one sample", 1);
    parser.add_option("d", "Discard the first samples of the time series (pass number of samples to be left out) -- allows for further thermalization.", 1);
    parser.add_option("sort", "Sort replica timeseries by temperatures before doing any processing (simulate canonical data). This could hide correlations.");
    parser.add_option("save-tau-int", "Estimate and write out integrated autocorrelation times. Requires --sort");

    parser.add_option("global-tau", "Do not estimate statistical inefficiencies for individual bins, but only globally for each temperature -- g_km = g_k");
    parser.add_option("no-tau", "Ignore all differences in statistical inefficiencies when reweighting -- g_km = 1");

    parser.add_option("cross-corr", "Calculate (histogram bin) cross-correlation coefficients for H_km, H_kn");
    parser.add_option("cross-corr-alt", "Calculate (histogram bin) cross-correlation coefficients for H_km, H_kn using an alternative method (probably slow and bad)");

    parser.add_option("autocorr-plots", "Write out the data points used to estimate (bin) statistical inefficiencies to check the form of the auto-correlation functions");

    parser.add_option("time-series-format", "Set to number of columns: 1 (default) or 2; 1-column time series are already sorted by control parameter", 1);

    //further general arguments: file names of energy/observable time series
    parser.parse(argc, argv);

    //echo whole commandline:
    cout << "command line: ";
    for (int arg = 0; arg < argc; ++arg) {
        cout << argv[arg] << " ";
    }
    cout << endl;

    const char* one_time_opts[] = {"info", "b", "loadz", "savez", "n", "cp-range", "cp-auto-range", "j", "i", "sub-sample", "sort", "time-series-format"};
    parser.check_one_time_options(one_time_opts);
    const char* incompatible1[] = {"global-tau", "no-tau"};
    parser.check_incompatible_options(incompatible1);
    const char* incompatible2[] = {"autocorr-plots", "no-tau"};
    parser.check_incompatible_options(incompatible2);
    const char* incompatible3[] = {"b", "discrete-ising-bins"};
    parser.check_incompatible_options(incompatible3);
    const char* incompatible4[] = {"cp-range", "cp-auto-range"};
    parser.check_incompatible_options(incompatible4);

    if (parser.option("help")) {
        cout << "Multihistogram reweighting for time series originating from parallel tempering or canonical simulations" << endl;
        cout << "Command line options understood:" << endl;
        parser.print_options(cout);
        cout << endl;
        return;
    }

    if (const clp::option_type& jk = parser.option("j")) {
        setJackknife(true, fromString<unsigned>(jk.argument()));
    }

    be_quiet = parser.option("q");
    infoFilename = (parser.option("info") ?
            parser.option("info").argument() : "info.dat");

    if (not parser.option("b")) {
        if (parser.option("discrete-ising-bins")) {
            discreteIsingBins = true;
        } else {
            cerr << "energy bin count not specified (option -b)!" << endl;
        }
    } else {
        binCount = dlib::sa = parser.option("b").argument();
    }

    do_directEstimates = parser.option("direct");

    non_iterative = parser.option("non-iterative");
    maxIterations = (non_iterative ? 0 : 10000);            //if non-iterative estimation is attempted, by default don't do any iterations, else default to 1000
    if (parser.option("i")) {
        maxIterations = dlib::sa = parser.option("i").argument();
    }
    if (parser.option("t")) {
        iterationTolerance = dlib::sa = parser.option("t").argument();
    }

    bool createHistograms = parser.option("h");

    if (const clp::option_type& ss = parser.option("sub-sample")) {
        subsampleHowMuch = dlib::sa = ss.argument();
    }

    if (const clp::option_type& dd = parser.option("d")) {
        discardSamples = dlib::sa = dd.argument();
    }

    sortByCp = parser.option("sort");
    saveTauInt = sortByCp and parser.option("save-tau-int");
    zInFile  = (parser.option("loadz") ? parser.option("loadz").argument() : "");
    zOutFile = (parser.option("savez") ? parser.option("savez").argument() : "");

    globalTau = parser.option("global-tau");
    noTau = parser.option("no-tau");
    autocorrPlots = parser.option("autocorr-plots");
    crossCorr = parser.option("cross-corr");
    crossCorrAlt = parser.option("cross-corr-alt");

    if (const clp::option_type& tsf_opt = parser.option("time-series-format")) {
        std::string tsf = tsf_opt.argument();
        if (tsf == "1") {
            timeSeriesFormat = COL1;
        } else if (tsf == "2") {
            timeSeriesFormat = COL2;
        } else {
            cerr << "Invalid time series format -- should be \"1\" or \"2\"" << endl;
        }
    }
    
    init();

    if (const clp::option_type& rr = parser.option("cp-range")) {
        double cpMin = dlib::sa = rr.argument(0);
        double cpMax = dlib::sa = rr.argument(1);
        double cpStep = dlib::sa = rr.argument(2);
        reweightRange(cpMin, cpMax, cpStep, createHistograms);
    }

    if (const clp::option_type& rr = parser.option("cp-auto-range")) {
        // double cpMin = dlib::sa = rr.argument(0);
        // double cpMax = dlib::sa = rr.argument(1);
        auto cpMinMax = std::minmax_element(mr->controlParameterValues.begin(),
                                            mr->controlParameterValues.end());
        double cpMin = *cpMinMax.first;
        double cpMax = *cpMinMax.second;
        double cpStep = dlib::sa = rr.argument(0);
        reweightRange(cpMin, cpMax, cpStep, createHistograms);
    }    

    if (const clp::option_type& rr = parser.option("cp-range-discrete")) {
        double cpMin = dlib::sa = rr.argument(0);
        double cpMax = dlib::sa = rr.argument(1);
        double cpStep = dlib::sa = rr.argument(2);
        reweightDiscreteRange(cpMin, cpMax, cpStep, createHistograms);
    }

    if (const clp::option_type& fms = parser.option("max-susc")) {
        double findMaxSuscCpStart = dlib::sa = fms.argument(0);
        double findMaxSuscCpEnd = dlib::sa = fms.argument(1);
        findMaxSusc(findMaxSuscCpStart, findMaxSuscCpEnd);
    }

    if (const clp::option_type& fms = parser.option("min-binder")) {
        double findMinBinderCpStart = dlib::sa = fms.argument(0);
        double findMinBinderCpEnd = dlib::sa = fms.argument(1);
        findMinBinder(findMinBinderCpStart, findMinBinderCpEnd);
    }

    if (const clp::option_type& fms = parser.option("max-specific-heat")) {
        double findMaxSpecificHeatCpStart = dlib::sa = fms.argument(0);
        double findMaxSpecificHeatCpEnd = dlib::sa = fms.argument(1);
        findMaxSpecificHeat(findMaxSpecificHeatCpStart, findMaxSpecificHeatCpEnd);
    }

    double peakTolerance = .05;
    if (const clp::option_type& pt = parser.option("peak-tolerance")) {
        peakTolerance = dlib::sa = pt.argument(0);
    }

    if (const clp::option_type& dp = parser.option("energy-double-peak")) {
        double cpStart = dlib::sa = dp.argument(0);
        double cpEnd = dlib::sa = dp.argument(1);
        findEnergyDoublePeak(cpStart, cpEnd, peakTolerance);
    }

    if (const clp::option_type& dp = parser.option("obs-double-peak")) {
        double cpStart = dlib::sa = dp.argument(0);
        double cpEnd = dlib::sa = dp.argument(1);
        findObservableDoublePeak(cpStart, cpEnd, peakTolerance);
    }

    if (const clp::option_type& rda = parser.option("reldip-at")) {
        double targetControlParameter = dlib::sa = rda.argument(0);
        findEnergyRelDip(targetControlParameter, peakTolerance);
        findObservableRelDip(targetControlParameter, peakTolerance);
    }
}


//maps cp->observable (or function there of, their errors)
//reset in init(), afterwards grow after various reweighting calls
typedef map<double, double> Map;
typedef std::shared_ptr<Map> MapPtr;
//results from multi-histogram reweighting:
MapPtr energy;
MapPtr specificHeat;
MapPtr observable;
MapPtr observableSquared;
MapPtr susceptibility;
MapPtr binder;
MapPtr binderRatio;
MapPtr energyError;
MapPtr specificHeatError;
MapPtr observableError;
MapPtr observableSquaredError;
MapPtr susceptibilityError;
MapPtr binderError;
MapPtr binderRatioError;
//results from direct averaging of time series sorted by temperature:
MapPtr direct_energy;
MapPtr direct_specificHeat;
MapPtr direct_observable;
MapPtr direct_observableSquared;
MapPtr direct_susceptibility;
MapPtr direct_binder;
MapPtr direct_binderRatio;
MapPtr direct_energyError;
MapPtr direct_specificHeatError;
MapPtr direct_observableError;
MapPtr direct_observableSquaredError;
MapPtr direct_susceptibilityError;
MapPtr direct_binderError;
MapPtr direct_binderRatioError;

//internal function to output the above maps
void writeOutResults() {
    //reweighting results:
    if (energy and not energy->empty()) {
        DoubleMapWriter energyOut;
        energyOut.setData(energy);
        if (use_jackknife) energyOut.setErrors(energyError);
        energyOut.addHeaderText("MRPT estimates of energy");
        if (use_jackknife) energyOut.addHeaderText("jackknife error estimation");
        energyOut.addMeta("energyBins", binCount);
        energyOut.addMeta("observable", "energy");
        energyOut.addMeta("L", getSystemL());
        energyOut.addMeta("N", getSystemN());
        energyOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) energyOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        energyOut.addHeaderText(getControlParameterName()+"\t energy" + headerSuffix);
        energyOut.writeToFile(outputDirPrefix + "mrpt-energy-l-" + numToString(getSystemL()) + ".values");
    }

    if (specificHeat and not specificHeat->empty()) {
        DoubleMapWriter specificHeatOut;
        specificHeatOut.setData(specificHeat);
        if (use_jackknife) specificHeatOut.setErrors(specificHeatError);
        specificHeatOut.addHeaderText("MRPT estimates of specific heat");
        if (use_jackknife) specificHeatOut.addHeaderText("jackknife error estimation");
        specificHeatOut.addMeta("energyBins", binCount);
        specificHeatOut.addMeta("observable", "specificHeat");
        specificHeatOut.addMeta("L", getSystemL());
        specificHeatOut.addMeta("N", getSystemN());
        specificHeatOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) specificHeatOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        specificHeatOut.addHeaderText(getControlParameterName()+"\t specificHeat" + headerSuffix);
        specificHeatOut.writeToFile(outputDirPrefix + "mrpt-specific-heat-l-" + numToString(getSystemL()) + ".values");
    }

    if (observable and not observable->empty()) {
        DoubleMapWriter observableOut;
        observableOut.setData(observable);
        if (use_jackknife) observableOut.setErrors(observableError);
        observableOut.addHeaderText("MRPT estimates of " + getObservableName());
        if (use_jackknife) observableOut.addHeaderText("jackknife error estimation");
        observableOut.addMeta("energyBins", binCount);
        observableOut.addMeta("observable", getObservableName());
        observableOut.addMeta("L", getSystemL());
        observableOut.addMeta("N", getSystemN());
        observableOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) observableOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        observableOut.addHeaderText(getControlParameterName()+"\t " + getObservableName() + headerSuffix);
        observableOut.writeToFile(outputDirPrefix + "mrpt-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

    if (observableSquared and not observableSquared->empty()) {
        DoubleMapWriter observableSquaredOut;
        observableSquaredOut.setData(observableSquared);
        if (use_jackknife) observableSquaredOut.setErrors(observableSquaredError);
        observableSquaredOut.addHeaderText("MRPT estimates of " + getObservableName() + " squared");
        if (use_jackknife) observableSquaredOut.addHeaderText("jackknife error estimation");
        observableSquaredOut.addMeta("energyBins", binCount);
        observableSquaredOut.addMeta("observable", getObservableName() + "Squared");
        observableSquaredOut.addMeta("L", getSystemL());
        observableSquaredOut.addMeta("N", getSystemN());
        observableSquaredOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) observableSquaredOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        observableSquaredOut.addHeaderText(getControlParameterName()+"\t " +
                                           getObservableName() + "Squared" +
                                           headerSuffix);
        observableSquaredOut.writeToFile(outputDirPrefix + "mrpt-" + getObservableName() + "Squared" + "-l-" + numToString(getSystemL()) + ".values");
    }
    

    if (susceptibility and not susceptibility->empty()) {
        DoubleMapWriter susceptibilityOut;
        susceptibilityOut.setData(susceptibility);
        if (use_jackknife) susceptibilityOut.setErrors(susceptibilityError);
        susceptibilityOut.addHeaderText("MRPT estimates of " + getObservableName() + " susceptibility");
        if (use_jackknife) susceptibilityOut.addHeaderText("jackknife error estimation");
        susceptibilityOut.addMeta("energyBins", binCount);
        susceptibilityOut.addMeta("observable", "susc-" + getObservableName());
        susceptibilityOut.addMeta("L", getSystemL());
        susceptibilityOut.addMeta("N", getSystemN());
        susceptibilityOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) susceptibilityOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        susceptibilityOut.addHeaderText(getControlParameterName()+"\t susc" + headerSuffix);
        susceptibilityOut.writeToFile(outputDirPrefix + "mrpt-susc-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

    if (binder and not binder->empty()) {
        DoubleMapWriter binderOut;
        binderOut.setData(binder);
        if (use_jackknife) binderOut.setErrors(binderError);
        binderOut.addHeaderText("MRPT estimates of " + getObservableName() + " binder parameter");
        if (use_jackknife) binderOut.addHeaderText("jackknife error estimation");
        binderOut.addMeta("energyBins", binCount);
        binderOut.addMeta("observable", "binder-" + getObservableName());
        binderOut.addMeta("L", getSystemL());
        binderOut.addMeta("N", getSystemN());
        binderOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) binderOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        binderOut.addHeaderText(getControlParameterName()+"\t binder" + headerSuffix);
        binderOut.writeToFile(outputDirPrefix + "mrpt-binder-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

    if (binderRatio and not binderRatio->empty()) {
        DoubleMapWriter binderRatioOut;
        binderRatioOut.setData(binderRatio);
        if (use_jackknife) binderRatioOut.setErrors(binderRatioError);
        binderRatioOut.addHeaderText("MRPT estimates of " + getObservableName() + " binder ratio parameter");
        if (use_jackknife) binderRatioOut.addHeaderText("jackknife error estimation");
        binderRatioOut.addMeta("energyBins", binCount);
        binderRatioOut.addMeta("observable", "binderRatio-" + getObservableName());
        binderRatioOut.addMeta("L", getSystemL());
        binderRatioOut.addMeta("N", getSystemN());
        binderRatioOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) binderRatioOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        binderRatioOut.addHeaderText(getControlParameterName()+"\t binderRatio" + headerSuffix);
        binderRatioOut.writeToFile(outputDirPrefix + "mrpt-binderRatio-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }
    

    //results from direct averaging:
    if (direct_energy and not direct_energy->empty()) {
        DoubleMapWriter energyOut;
        energyOut.setData(direct_energy);
        if (use_jackknife) energyOut.setErrors(direct_energyError);
        energyOut.addHeaderText("Direct estimates of energy");
        if (use_jackknife) energyOut.addHeaderText("jackknife error estimation");
        energyOut.addMeta("observable", "energy");
        energyOut.addMeta("L", getSystemL());
        energyOut.addMeta("N", getSystemN());
        energyOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) energyOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        energyOut.addHeaderText(getControlParameterName()+"\t energy" + headerSuffix);
        energyOut.writeToFile(outputDirPrefix + "mrpt-direct-energy-l-" + numToString(getSystemL()) + ".values");
    }

    if (direct_specificHeat and not direct_specificHeat->empty()) {
        DoubleMapWriter specificHeatOut;
        specificHeatOut.setData(direct_specificHeat);
        if (use_jackknife) specificHeatOut.setErrors(direct_specificHeatError);
        specificHeatOut.addHeaderText("Direct estimates of specific heat");
        if (use_jackknife) specificHeatOut.addHeaderText("jackknife error estimation");
        specificHeatOut.addMeta("observable", "specificHeat");
        specificHeatOut.addMeta("L", getSystemL());
        specificHeatOut.addMeta("N", getSystemN());
        specificHeatOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) specificHeatOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        specificHeatOut.addHeaderText(getControlParameterName()+"\t specificHeat" + headerSuffix);
        specificHeatOut.writeToFile(outputDirPrefix + "mrpt-direct-specific-heat-l-" + numToString(getSystemL()) + ".values");
    }

    if (direct_observable and not direct_observable->empty()) {
        DoubleMapWriter observableOut;
        observableOut.setData(direct_observable);
        if (use_jackknife) observableOut.setErrors(direct_observableError);
        observableOut.addHeaderText("Direct estimates of " + getObservableName());
        if (use_jackknife) observableOut.addHeaderText("jackknife error estimation");
        observableOut.addMeta("observable", getObservableName());
        observableOut.addMeta("L", getSystemL());
        observableOut.addMeta("N", getSystemN());
        observableOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) observableOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        observableOut.addHeaderText(getControlParameterName()+"\t " + getObservableName() + headerSuffix);
        observableOut.writeToFile(outputDirPrefix + "mrpt-direct-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

    if (direct_observableSquared and not direct_observableSquared->empty()) {
        DoubleMapWriter observableSquaredOut;
        observableSquaredOut.setData(direct_observableSquared);
        if (use_jackknife) observableSquaredOut.setErrors(direct_observableSquaredError);
        observableSquaredOut.addHeaderText("Direct estimates of " + getObservableName() + " squared");
        if (use_jackknife) observableSquaredOut.addHeaderText("jackknife error estimation");
        observableSquaredOut.addMeta("observable", getObservableName() + "Squared");
        observableSquaredOut.addMeta("L", getSystemL());
        observableSquaredOut.addMeta("N", getSystemN());
        observableSquaredOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) observableSquaredOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        observableSquaredOut.addHeaderText(getControlParameterName()+"\t " +
                                           getObservableName() + "Squared" +
                                           headerSuffix);
        observableSquaredOut.writeToFile(outputDirPrefix + "mrpt-direct-" + getObservableName() + "Squared" + "-l-" + numToString(getSystemL()) + ".values");
    }


    if (direct_susceptibility and not direct_susceptibility->empty()) {
        DoubleMapWriter susceptibilityOut;
        susceptibilityOut.setData(direct_susceptibility);
        if (use_jackknife) susceptibilityOut.setErrors(direct_susceptibilityError);
        susceptibilityOut.addHeaderText("Direct estimates of " + getObservableName() + " susceptibility");
        if (use_jackknife) susceptibilityOut.addHeaderText("jackknife error estimation");
        susceptibilityOut.addMeta("observable", "susc-" + getObservableName());
        susceptibilityOut.addMeta("L", getSystemL());
        susceptibilityOut.addMeta("N", getSystemN());
        susceptibilityOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) susceptibilityOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        susceptibilityOut.addHeaderText(getControlParameterName()+"\t susc" + headerSuffix);
        susceptibilityOut.writeToFile(outputDirPrefix + "mrpt-direct-susc-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

    if (direct_binder and not direct_binder->empty()) {
        DoubleMapWriter binderOut;
        binderOut.setData(direct_binder);
        if (use_jackknife) binderOut.setErrors(direct_binderError);
        binderOut.addHeaderText("Direct estimates of " + getObservableName() + " binder parameter");
        if (use_jackknife) binderOut.addHeaderText("jackknife error estimation");
        binderOut.addMeta("observable", "binder-" + getObservableName());
        binderOut.addMeta("L", getSystemL());
        binderOut.addMeta("N", getSystemN());
        binderOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) binderOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        binderOut.addHeaderText(getControlParameterName()+"\t binder" + headerSuffix);
        binderOut.writeToFile(outputDirPrefix + "mrpt-direct-binder-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

    if (direct_binderRatio and not direct_binderRatio->empty()) {
        DoubleMapWriter binderRatioOut;
        binderRatioOut.setData(direct_binderRatio);
        if (use_jackknife) binderRatioOut.setErrors(direct_binderRatioError);
        binderRatioOut.addHeaderText("Direct estimates of " + getObservableName() + " binder ratio parameter");
        if (use_jackknife) binderRatioOut.addHeaderText("jackknife error estimation");
        binderRatioOut.addMeta("observable", "binderRatio-" + getObservableName());
        binderRatioOut.addMeta("L", getSystemL());
        binderRatioOut.addMeta("N", getSystemN());
        binderRatioOut.addMeta("controlParameterName", getControlParameterName());
        if (use_jackknife) binderRatioOut.addMeta("jackknifeBlockcount", jackknifeBlocks);
        binderRatioOut.addHeaderText(getControlParameterName()+"\t binderRatio" + headerSuffix);
        binderRatioOut.writeToFile(outputDirPrefix + "mrpt-direct-binderRatio-" + getObservableName() + "-l-" + numToString(getSystemL()) + ".values");
    }

}

void setSubsample(unsigned samplesSize) {
    subsampleHowMuch = samplesSize;
}

void setOutputDirectory(const char *dir) {
    string directory = dir;
    if (directory == "") directory = ".";
    outputDirPrefix = directory + "/";
}

void setInfoFilename(const char *filename) {
    infoFilename = filename;
}

void setBins(unsigned bins) {
    binCount = bins;
}

void setJackknife(bool useJackknife, unsigned blocks) {
    use_jackknife = useJackknife;
    jackknifeBlocks = blocks;
    headerSuffix = (use_jackknife ? "\t error" : "");
}

void setQuiet(bool quiet) {
    be_quiet = quiet;
}

void setMaxIterations(unsigned max_iterations) {
    maxIterations = max_iterations;
}

void setTolerance(double tolerance) {
    iterationTolerance = tolerance;
}

void init() {
    destroy(mr);
    energy = MapPtr(new Map());
    specificHeat = MapPtr(new Map());
    observable = MapPtr(new Map());
    observableSquared = MapPtr(new Map());    
    susceptibility = MapPtr(new Map());
    binder = MapPtr(new Map());
    binderRatio = MapPtr(new Map());    
    energyError = MapPtr(new Map());
    specificHeatError = MapPtr(new Map());
    observableError = MapPtr(new Map());
    observableSquaredError = MapPtr(new Map());    
    susceptibilityError = MapPtr(new Map());
    binderError = MapPtr(new Map());
    binderRatioError = MapPtr(new Map());    
    direct_energy = MapPtr(new Map());
    direct_specificHeat = MapPtr(new Map());
    direct_observable = MapPtr(new Map());
    direct_observableSquared = MapPtr(new Map());    
    direct_susceptibility = MapPtr(new Map());
    direct_binder = MapPtr(new Map());
    direct_binderRatio = MapPtr(new Map());    
    direct_energyError = MapPtr(new Map());
    direct_specificHeatError = MapPtr(new Map());
    direct_observableError = MapPtr(new Map());
    direct_observableSquaredError = MapPtr(new Map());    
    direct_susceptibilityError = MapPtr(new Map());
    direct_binderError = MapPtr(new Map());
    direct_binderRatioError = MapPtr(new Map());    
    mr = (use_jackknife ?
        new MultireweightHistosPTJK(jackknifeBlocks, be_quiet ? dev_null : cout) :
        new MultireweightHistosPT(be_quiet ? dev_null : cout));

    mr->addSimulationInfo(infoFilename);

    //TODO: currently command line arguments are the only way to specify
    //input time series
    for (unsigned arg = 0; arg < parser.number_of_arguments(); ++arg) {
        switch (timeSeriesFormat) {
        case COL1:
            mr->addInputTimeSeries_singleColumn(parser[arg], subsampleHowMuch, discardSamples);
            break;
        case COL2:
            mr->addInputTimeSeries_twoColumn(parser[arg], subsampleHowMuch, discardSamples);
            break;
        }
    }

    if (sortByCp) {
        mr->sortTimeSeriesByControlParameter();
    }

    if (do_directEstimates) {
        directResults();
    }

    if (discreteIsingBins) {
        mr->createHistogramsIsing();
    } else {
        mr->createHistograms(binCount);
    }
    mr->saveH_km(outputDirPrefix + "Hkm.table");

    if (crossCorr) {
        mr->computeAndSaveHistogramCrossCorr();
    }
    if (crossCorrAlt) {
        mr->computeAndSaveHistogramCrossCorrAlt();
    }

    if (use_jackknife) {
        //TODO: ugly, ugly, ugly
        dynamic_cast<MultireweightHistosPTJK*>(mr)->
                saveH_km_errors(outputDirPrefix + "Hkm-errors.table");
    }
    mr->saveU_m(outputDirPrefix + "Um.table");

    if (non_iterative) {
        mr->findDensityOfStatesNonIteratively();
    }

    if (noTau) {
        mr->setBinInefficienciesToUnity();
    } else if (globalTau) {
        mr->measureGlobalInefficiencies(autocorrPlots);
    } else {
        mr->measureBinInefficiencies(autocorrPlots);
    }

    if (saveTauInt) {
        mr->writeOutEnergyTauInt("mrpt-tauint-energy.dat");
        mr->writeOutObsTauInt("mrpt-tauint-" + mr->observable + ".dat");
    }

    mr->saveg_km(outputDirPrefix + "gkm.table");

    mr->updateEffectiveCounts();

    //those quantities are not really interesting:
//    mr->saveNeff_lm(outputDirPrefix + "Nefflm.table");
//    mr->saveNeff_l(outputDirPrefix + "Neffl.table");

    if (zInFile != "") {
        //load partition functions as starting point for iteration
        mr->loadPartitionFunctions(zInFile);
    }

    if (maxIterations > 0) {
        mr->findPartitionFunctionsAndDensityOfStates(iterationTolerance, maxIterations);
    }

    if (discreteIsingBins) {
        mr->saveLogDensityOfStatesIsing(outputDirPrefix + "mrpt-dos.dat");
    } else {
        mr->saveLogDensityOfStates(outputDirPrefix + "mrpt-dos.dat");
    }

    if (zOutFile != "") {
        mr->savePartitionFunctions(zOutFile);
    }
}

void directResults() {
    typedef MultireweightHistosPT::ResultsMap ResMap;
    ResMap* results = mr->directNoReweighting();

    for (ResMap::const_iterator iter = results->begin();
            iter != results->end(); ++iter) {
        double cp = iter->first;
        ReweightingResult values = iter->second;
        (*direct_energy)[cp] = values.energyAvg;
        (*direct_specificHeat)[cp] = values.heatCapacity;
        (*direct_observable)[cp] = values.obsAvg;
        (*direct_observableSquared)[cp] = values.obsSquared;
        (*direct_susceptibility)[cp] = values.obsSusc;
        (*direct_binder)[cp] = values.obsBinder;
        (*direct_binderRatio)[cp] = values.obsBinderRatio;        
        if (use_jackknife) {
            (*direct_energyError)[cp] = values.energyError;
            (*direct_specificHeatError)[cp] = values.heatCapacityError;
            (*direct_observableError)[cp] = values.obsError;
            (*direct_observableSquaredError)[cp] = values.obsSquaredError;            
            (*direct_susceptibilityError)[cp] = values.obsSuscError;
            (*direct_binderError)[cp] = values.obsBinderError;
            (*direct_binderRatioError)[cp] = values.obsBinderRatioError;                                                                  
        }
    }

    writeOutResults();

    destroy(results);
}



//inline class somewhat like lambda function (restriction: can't access "auto" variables
//in containing function):
class ReweightAndHandle {
    bool createHistograms;
public:
    ReweightAndHandle(bool withHistograms = false) : createHistograms(withHistograms)
    { }
    void operator()(double cp) {
        ReweightingResult result = (
                createHistograms ?
                        mr->reweightWithHistograms(cp, binCount) :
                        mr->reweight(cp));
        (*energy)[cp] = result.energyAvg;
        (*specificHeat)[cp] = result.heatCapacity;
        (*observable)[cp] = result.obsAvg;
        (*observableSquared)[cp] = result.obsSquared;  
        (*susceptibility)[cp] = result.obsSusc;
        (*binder)[cp] = result.obsBinder;
        (*binderRatio)[cp] = result.obsBinderRatio;
        if (use_jackknife) {
            (*energyError)[cp] = result.energyError;
            (*specificHeatError)[cp] = result.heatCapacityError;
            (*observableError)[cp] = result.obsError;
            (*observableSquaredError)[cp] = result.obsSquaredError;
            (*susceptibilityError)[cp] = result.obsSuscError;
            (*binderError)[cp] = result.obsBinderError;            
            (*binderRatioError)[cp] = result.obsBinderRatioError;
        }
        if (createHistograms) {
            result.energyHistogram->save("mrpt-energy-" + getControlParameterName() +
                                         numToString(cp) + ".hist");
            result.obsHistogram->save("mrpt-" + getObservableName() + "-" +
                                      getControlParameterName() + numToString(cp) + ".hist");
        }
        result.freeMemory();
    }
};

class ReweightAndHandleDiscrete {
    bool createHistogram;
public:
    ReweightAndHandleDiscrete(bool withHistogram = false) : createHistogram(withHistogram)
    { }
    void operator()(double cp) {
        ReweightingResult result =
                mr->reweightDiscrete(cp);
        (*energy)[cp] = result.energyAvg;
        (*specificHeat)[cp] = result.heatCapacity;
        if (use_jackknife) {
            (*energyError)[cp] = result.energyError;
            (*specificHeatError)[cp] = result.heatCapacityError;
        }
        if (createHistogram) {
            result.energyHistogram = mr->reweightEnergyHistogram(cp);
            result.energyHistogram->save("mrpt-energy-" + getControlParameterName()
                                         + numToString(cp) + ".hist");
        }
        result.freeMemory();
    }
};


void reweight(double cp, bool createHistogramsToo) {
    ReweightAndHandle reweight(createHistogramsToo);
    reweight(cp);
    writeOutResults();
}

void reweightDiscrete(double cp, bool createHistogramToo) {
    ReweightAndHandleDiscrete reweight(createHistogramToo);
    reweight(cp);
    writeOutResults();
}


void reweightEnergyHistogram(double cp) {
    HistogramDouble* histo = mr->reweightEnergyHistogram(cp);
    histo->save("mrpt-energy-" + getControlParameterName()
                + numToString(cp) + ".hist");
    destroy(histo);
}

void reweightObservableHistogram(double cp) {
    HistogramDouble* histo = mr->reweightObservableHistogram(cp, binCount);
    histo->save("mrpt-" + getObservableName() + "-" + getControlParameterName()
                + numToString(cp) + ".hist");
    destroy(histo);
}


void reweightRange(double cpMin, double cpMax, double cpStep,
        bool createHistogramsToo) {
    ReweightAndHandle reweight(createHistogramsToo);
    for (double cp = cpMin; cp <= cpMax; cp += cpStep) {
        reweight(cp);
    }
    writeOutResults();
}

void reweightDiscreteRange(double cpMin, double cpMax, double cpStep, bool createHistogramsToo) {
    ReweightAndHandleDiscrete reweight(createHistogramsToo);
    for (double cp = cpMin; cp <= cpMax; cp += cpStep) {
        reweight(cp);
    }
    writeOutResults();
}


void findMaxSusc(double cpStart, double cpEnd) {
    double cpMax;
    double suscMax;
    double cpMaxError;
    double suscMaxError;
    if (not use_jackknife) {
        mr->findMaxObservableSusceptibility(cpMax, suscMax,
                                            *susceptibility,
                                            cpStart, cpEnd);
    } else {
        //TODO: store evaluated points somewhere
        vector<map<double,double> > v(jackknifeBlocks);
        static_cast<MultireweightHistosPTJK*>(mr)->
            findMaxObservableSusceptibility(cpMax, cpMaxError,
                                            suscMax, suscMaxError,
                                            *susceptibility, v,
                                            cpStart, cpEnd);
    }
    HistogramDouble* histo = mr->
            reweightObservableHistogram(cpMax, binCount);
    histo->save(outputDirPrefix + "mrpt-max-susc.hist");
    destroy(histo);

    MetadataMap meta;
    meta["L"] = numToString(mr->systemL);
    meta["N"] = numToString(mr->systemN);
    meta["systemSize"] = numToString(mr->systemSize);
    meta[getControlParameterName()] = numToString(cpMax, 16);
    meta["susc"] = numToString(suscMax, 16);
    if (use_jackknife) {
        meta[getControlParameterName() + "Error"] = numToString(cpMaxError, 16);
        meta["suscError"] = numToString(suscMaxError, 16);
    }
    string comments = "Maximum of " + mr->observable + " susceptibility, from MRPT\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-max-susc.dat", meta,
            comments);

    writeOutResults();
}

void findMinBinder(double cpStart, double cpEnd) {
    double cpMin;
    double binderMin;
    double cpMinError;
    double binderMinError;
    if (not use_jackknife) {
        mr->findMinBinder(cpMin, binderMin,
                          *binder,
                          cpStart, cpEnd);
    } else {
        //TODO: store evaluated points somewhere
        vector<map<double,double> > v(jackknifeBlocks);
        static_cast<MultireweightHistosPTJK*>(mr)->
                findMinBinder(cpMin, cpMinError,
                        binderMin, binderMinError,
                        *binder, v, cpStart, cpEnd);
    }
    HistogramDouble* histo = mr->
            reweightObservableHistogram(cpMin, binCount);
    histo->save(outputDirPrefix + "mrpt-min-binder.hist");
    destroy(histo);

    MetadataMap meta;
    meta["L"] = numToString(mr->systemL);
    meta["N"] = numToString(mr->systemN);
    meta["systemSize"] = numToString(mr->systemSize);
    meta[getControlParameterName()] = numToString(cpMin, 16);
    meta["binder"] = numToString(binderMin, 16);
    if (use_jackknife) {
        meta[getControlParameterName()+"Error"] = numToString(cpMinError, 16);
        meta["binderError"] = numToString(binderMinError, 16);
    }
    string comments = "Minimum of " + mr->observable + " binder cumulant, from MRPT\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-min-binder.dat", meta,
            comments);

    writeOutResults();
}

void findMaxSpecificHeat(double cpStart, double cpEnd) {
    double cpMax;
    double specificHeatMax;
    double cpMaxError;
    double specificHeatMaxError;
    if (not use_jackknife) {
        mr->findMaxSpecificHeatDiscrete(cpMax, specificHeatMax,
                                        *specificHeat,
                                        cpStart, cpEnd);
    } else {
        //TODO: store evaluated points somewhere
        vector<map<double,double> > v(jackknifeBlocks);
        static_cast<MultireweightHistosPTJK*>(mr)->
            findMaxSpecificHeatDiscrete(cpMax, cpMaxError,
                                        specificHeatMax, specificHeatMaxError,
                                        *specificHeat, v,
                                        cpStart, cpEnd);
    }
    HistogramDouble* histo = mr->reweightEnergyHistogram(cpMax);
    histo->save(outputDirPrefix + "mrpt-max-heat-capacity.hist");
    destroy(histo);

    MetadataMap meta;
    meta["L"] = numToString(mr->systemL);
    meta["N"] = numToString(mr->systemN);
    meta["systemSize"] = numToString(mr->systemSize);
    meta[getControlParameterName()] = numToString(cpMax, 16);
    meta["heatCapacity"] = numToString(specificHeatMax, 16);
    if (use_jackknife) {
        meta[getControlParameterName() + "Error"] = numToString(cpMaxError, 16);
        meta["heatCapacityError"] = numToString(specificHeatMaxError, 16);
    }
    string comments = "Maximum of heat capacity, from MRPT\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-heat-capacity.dat", meta,
            comments);

    writeOutResults();
}

void findEnergyDoublePeak(double cpStart, double cpEnd, double tolerance) {
    double cpDoubleEH;
    double relDipEH;
    double cpDoubleErrorEH;
    double relDipErrorEH;
    HistogramDouble* histoEH = 0;
    double cpDoubleEW;
    double relDipEW;
    double cpDoubleErrorEW;
    double relDipErrorEW;
    HistogramDouble* histoEW = 0;
    if (not use_jackknife) {
        mr->findEnergyEqualHeight(cpDoubleEH, relDipEH, histoEH,
                                  cpStart, cpEnd, tolerance);
        mr->findEnergyEqualWeight(cpDoubleEW, relDipEW, histoEW,
                                  histoEH, cpStart, cpEnd, tolerance);
    } else {
        static_cast<MultireweightHistosPTJK*>(mr)->
            findEnergyEqualHeightWeight(cpDoubleEH, cpDoubleErrorEH,
                                        relDipEH, relDipErrorEH, histoEH,
                                        cpDoubleEW, cpDoubleErrorEW, relDipEW,
                                        relDipErrorEW, histoEW,
                                        cpStart, cpEnd, tolerance);
    }
    histoEH->save(outputDirPrefix + "mrpt-energy-equal-height.hist");

    MetadataMap metaEH;
    metaEH["observable"] = "energy";
    metaEH["L"] = numToString(mr->systemL);
    metaEH["N"] = numToString(mr->systemN);
    metaEH["systemSize"] = numToString(mr->systemSize);    
    metaEH[getControlParameterName()] = numToString(cpDoubleEH, 16);
    metaEH["relDip"] = numToString(relDipEH, 16);
    if (use_jackknife) {
        metaEH[getControlParameterName() + "Error"] = numToString(cpDoubleErrorEH, 16);
        metaEH["relDipError"] = numToString(relDipErrorEH, 16);
    }
    string comments = "Location of equal-height double-peak energy histogram, from MRPT\n";
    comments += "relDip is H_max / H_min\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-energy-equal-height.dat", metaEH,
            comments);

    histoEW->save(outputDirPrefix + "mrpt-energy-equal-weight.hist");

    MetadataMap metaEW;
    metaEW["observable"] = "energy";
    metaEW["L"] = numToString(mr->systemL);
    metaEW["N"] = numToString(mr->systemN);
    metaEW["systemSize"] = numToString(mr->systemSize);    
    metaEW[getControlParameterName()] = numToString(cpDoubleEW, 16);
    metaEW["relDip"] = numToString(relDipEW, 16);
    if (use_jackknife) {
        metaEW[getControlParameterName() + "Error"] = numToString(cpDoubleErrorEW, 16);
        metaEW["relDipError"] = numToString(relDipErrorEW, 16);
    }
    comments = "Location of equal-weight double-peak energy histogram, from MRPT\n";
    comments += "relDip is H_max / H_min\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-energy-equal-weight.dat", metaEW,
            comments);

    destroy(histoEH);
    destroy(histoEW);
}

void findObservableDoublePeak(double cpStart, double cpEnd, double tolerance) {
    double cpDoubleEH;
    double relDipEH;
    double cpDoubleErrorEH;
    double relDipErrorEH;
    HistogramDouble* histoEH = 0;
    double cpDoubleEW;
    double relDipEW;
    double cpDoubleErrorEW;
    double relDipErrorEW;
    HistogramDouble* histoEW = 0;
    if (not use_jackknife) {
        mr->findObsEqualHeight(cpDoubleEH, relDipEH, histoEH,
                               cpStart, cpEnd, binCount, tolerance);
        mr->findObsEqualWeight(cpDoubleEW, relDipEW, histoEW,
                               histoEH, cpStart, cpEnd, binCount, tolerance);
    } else {
        static_cast<MultireweightHistosPTJK*>(mr)->
            findObservableEqualHeightWeight(
                cpDoubleEH, cpDoubleErrorEH,
                relDipEH, relDipErrorEH, histoEH,
                cpDoubleEW, cpDoubleErrorEW, relDipEW,
                relDipErrorEW, histoEW,
                cpStart, cpEnd, binCount, tolerance);
    }
    string obs = mr->observable;

    histoEH->save(outputDirPrefix + "mrpt-" + obs + "-equal-height.hist");

    MetadataMap metaEH;
    metaEH["observable"] = obs;
    metaEH["L"] = numToString(mr->systemL);
    metaEH["N"] = numToString(mr->systemN);
    metaEH["systemSize"] = numToString(mr->systemSize);    
    metaEH[getControlParameterName()] = numToString(cpDoubleEH, 16);
    metaEH["relDip"] = numToString(relDipEH, 16);
    if (use_jackknife) {
        metaEH[getControlParameterName() + "Error"] = numToString(cpDoubleErrorEH, 16);
        metaEH["relDipError"] = numToString(relDipErrorEH, 16);
    }
    string comments = "Location of equal-height double-peak " +
            obs + " histogram, from MRPT\n";
    comments += "relDip is H_max / H_min\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-" + obs +
            "-equal-height.dat", metaEH, comments);

    histoEW->save(outputDirPrefix + "mrpt-" + obs +
            "-equal-weight.hist");

    MetadataMap metaEW;
    metaEW["observable"] = obs;
    metaEW["L"] = numToString(mr->systemL);
    metaEW["N"] = numToString(mr->systemN);
    metaEW["systemSize"] = numToString(mr->systemSize);    
    metaEW[getControlParameterName()] = numToString(cpDoubleEW, 16);
    metaEW["relDip"] = numToString(relDipEW, 16);
    if (use_jackknife) {
        metaEW[getControlParameterName() + "Error"] = numToString(cpDoubleErrorEW, 16);
        metaEW["relDipError"] = numToString(relDipErrorEW, 16);
    }
    comments = "Location of equal-weight double-peak " + obs +
            "histogram, from MRPT\n";
    comments += "relDip is H_max / H_min\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-" + obs +
            "-equal-weight.dat", metaEW, comments);

    destroy(histoEH);
    destroy(histoEW);
}


void findEnergyRelDip(double targetControlParameter, double tolerance) {
    double relDip;
    double relDipError;
    HistogramDouble* histo = 0;
    if (not use_jackknife) {
        mr->energyRelDip(relDip, histo, targetControlParameter, tolerance);
    } else {
        static_cast<MultireweightHistosPTJK*>(mr)->
                energyRelDip(relDip, relDipError, histo,
                        targetControlParameter, tolerance);
    }
    string obs = "energy";

    histo->save(outputDirPrefix + "mrpt-" + obs + "-b" +
            numToString(targetControlParameter) + ".hist");

    MetadataMap meta;
    meta["observable"] = obs;
    meta["L"] = numToString(mr->systemL);
    meta["N"] = numToString(mr->systemN);
    meta["systemSize"] = numToString(mr->systemSize);    
    meta[getControlParameterName()] = numToString(targetControlParameter, 16);
    meta["relDip"] = numToString(relDip, 16);
    if (use_jackknife) {
        meta["relDipError"] = numToString(relDipError, 16);
    }
    string comments = "relDip is H_max / H_min\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-" + obs +
            "-b" + numToString(targetControlParameter) +
            "-reldip.dat", meta, comments);

    destroy(histo);
}

void findObservableRelDip(double targetControlParameter, double tolerance) {
    double relDip;
    double relDipError;
    HistogramDouble* histo = 0;
    if (not use_jackknife) {
        mr->obsRelDip(relDip, histo, targetControlParameter, binCount, tolerance);
    } else {
        static_cast<MultireweightHistosPTJK*>(mr)->
                obsRelDip(relDip, relDipError,
                        histo, targetControlParameter, binCount, tolerance);
    }
    string obs = mr->observable;

    histo->save(outputDirPrefix + "mrpt-" + obs + "-b" +
            numToString(targetControlParameter) + ".hist");

    MetadataMap meta;
    meta["observable"] = obs;
    meta["L"] = numToString(mr->systemL);
    meta["N"] = numToString(mr->systemN);
    meta["systemSize"] = numToString(mr->systemSize);
    meta[getControlParameterName()] = numToString(targetControlParameter, 16);
    meta["relDip"] = numToString(relDip, 16);
    if (use_jackknife) {
        meta["relDipError"] = numToString(relDipError, 16);
    }
    string comments = "relDip is H_max / H_min\n";
    if (use_jackknife) {
        comments += "Jackknife error estimation, blockCount: "
                + numToString(jackknifeBlocks) + "\n";
    }
    writeOnlyMetaData(outputDirPrefix + "mrpt-" + obs +
                      "-" + getControlParameterName() + numToString(targetControlParameter) +
                      "-reldip.dat", meta, comments);

    destroy(histo);
}


void getEnergyTimeSeries(unsigned k, int *outN_k, double **outArray1) {
    *outN_k = int(mr->energyTimeSeries[k]->size());
    *outArray1 = mr->energyTimeSeries[k]->data();
}

void getObservableTimeSeries(unsigned k, int *outN_k, double **outArray1) {
    *outN_k = int(mr->observableTimeSeries[k]->size());
    *outArray1 = mr->observableTimeSeries[k]->data();
}

void getCpIndexTimeSeries(unsigned k, int *outN_k, int **outArray1) {
    *outN_k = int(mr->cpiTimeSeries[k]->size());
    *outArray1 = mr->cpiTimeSeries[k]->data();
}

void getU_m(int *outM, double **outArray1) {
    *outM = mr->binCount;
    *outArray1 = mr->U_m.data();
}

void getH_km(int *outK, int *outM, int **outArray2) {
    *outK = mr->numReplicas;
    *outM = mr->binCount;
    *outArray2 = mr->H_km.data();
}

void getH_m(int *outM, int **outArray1) {
    *outM = mr->binCount;
    *outArray1 = mr->H_m.data();
}

void getg_km(int *outK, int *outM, double **outArray2) {
    *outK = mr->numReplicas;
    *outM = mr->binCount;
    *outArray2 = mr->g_km.data();
}

void getH_lm(int *outL, int *outM, int **outArray2) {
    *outL = mr->numReplicas;
    *outM = mr->binCount;
    *outArray2 = mr->H_lm.data();
}

void getN_kl(int *outK, int *outL, int **outArray2) {
    *outK = mr->numReplicas;
    *outL = mr->numReplicas;
    *outArray2 = mr->N_kl.data();
}

void getHeff_m(int *outM, double **outArray1) {
    *outM = mr->binCount;
    *outArray1 = mr->Heff_m.data();
}

void getNeff_lm(int *outL, int *outM, double **outArray2) {
    *outL = mr->numReplicas;
    *outM = mr->binCount;
    *outArray2 = mr->Neff_lm.data();
}

void getOriginalControlParameterValues(int *outK, double **outArray1) {
    if (mr) {
        *outK = mr->numReplicas;
        *outArray1 = mr->controlParameterValues.data();
    } else {
        *outK = mrbc[PBC]->numReplicas;
        *outArray1 = mrbc[PBC]->controlParameterValues.data();
    }
}

std::string getObservableName() {
    if (mr) {
        return mr->getObservableName();
    } else {
        return mrbc[PBC]->getObservableName();
    }
}

std::string getControlParameterName() {
    if (mr) {
        return mr->getControlParameterName();
    } else {
        return mrbc[PBC]->getControlParameterName();
    }
}

unsigned getSystemL() {
    if (mr) {
        return mr->getSystemL();
    } else {
        return mrbc[PBC]->getSystemL();
    }
}

unsigned getSystemN() {
    if (mr) {
        return mr->getSystemN();
    } else {
        return mrbc[PBC]->getSystemN();
    }
}




void initBC() {
    observable = MapPtr(new Map());
    observableSquared = MapPtr(new Map());    
    susceptibility = MapPtr(new Map());
    binder = MapPtr(new Map());
    binderRatio = MapPtr(new Map());    
    observableError = MapPtr(new Map());
    observableSquaredError = MapPtr(new Map());    
    susceptibilityError = MapPtr(new Map());
    binderError = MapPtr(new Map());
    binderRatioError = MapPtr(new Map());    
    direct_observable = MapPtr(new Map());
    direct_observableSquared = MapPtr(new Map());    
    direct_susceptibility = MapPtr(new Map());
    direct_binder = MapPtr(new Map());
    direct_binderRatio = MapPtr(new Map());    
    direct_observableError = MapPtr(new Map());
    direct_observableSquaredError = MapPtr(new Map());    
    direct_susceptibilityError = MapPtr(new Map());
    direct_binderError = MapPtr(new Map());
    direct_binderRatioError = MapPtr(new Map());    
    
    for (BC bc: all_BC) {
        std::shared_ptr<MultireweightHistosPT>& mr_instance = mrbc[bc];
        
        if (use_jackknife) {
            mr_instance = std::shared_ptr<MultireweightHistosPT>(
                new MultireweightHistosPTJK(jackknifeBlocks,
                                            be_quiet ? dev_null : cout));
        } else {
            mr_instance = std::shared_ptr<MultireweightHistosPT>(
                new MultireweightHistosPT(be_quiet ? dev_null : cout));
        }

        mr_instance->addSimulationInfo(infoFilenamesBC[bc]);
    }

    //TODO: currently command line arguments are the only way to specify
    //input time series
    namespace fs = boost::filesystem;
    for (unsigned arg = 0; arg < parser.number_of_arguments(); ++arg) {
        std::string series_filename = parser[arg];

        // find bc from infofilename path
        BC this_bc = NONE;
        for (BC bc: all_BC) {
            if (fs::canonical(fs::path(infoFilenamesBC[bc]).parent_path()) ==
                    fs::canonical(fs::path(series_filename).parent_path().parent_path())) {
                this_bc = bc;
                break;
            }
        }
        
        std::shared_ptr<MultireweightHistosPT> mr_instance = mrbc[this_bc];
        
        switch (timeSeriesFormat) {
        case COL1:
            mr_instance->addInputTimeSeries_singleColumn(series_filename, subsampleHowMuch, discardSamples);
            break;
        case COL2:
            mr_instance->addInputTimeSeries_twoColumn(series_filename, subsampleHowMuch, discardSamples);
            break;
        }
    }

    for (auto mr_instance: mrbc) {
        if (sortByCp) {
            mr_instance->sortTimeSeriesByControlParameter();
        }
        mr_instance->createHistograms(binCount);
    }

    // if (do_directEstimates) {
    //     directResultsBC();
    // }

    

    for (auto mr_instance: mrbc) {
        if (non_iterative) {
            mr_instance->findDensityOfStatesNonIteratively();
        }

        if (noTau) {
            mr_instance->setBinInefficienciesToUnity();
        } else if (globalTau) {
            mr_instance->measureGlobalInefficiencies(false);
        } else {
            mr_instance->measureBinInefficiencies(false);
        }

        mr_instance->updateEffectiveCounts();        

        if (maxIterations > 0) {
            mr_instance->findPartitionFunctionsAndDensityOfStates(iterationTolerance, maxIterations);
        }
        
    }
}


void initFromCommandLineBC(int argc, char** argv) {
    //Command line parsing
    parser.add_option("help", "display this help message");
    parser.add_option("q", "be less verbose");
    parser.add_option("info-pbc", "info generated by simulation (\"info.dat\"), pbc simulation", 1);
    parser.add_option("info-apbc-x", "info generated by simulation (\"info.dat\"), apbc-x simulation", 1);
    parser.add_option("info-apbc-y", "info generated by simulation (\"info.dat\"), apbc-y simulation", 1);
    parser.add_option("info-apbc-xy", "info generated by simulation (\"info.dat\"), apbc-xy simulation", 1);    
    parser.add_option("b", "number of energy bins", 1);
    parser.add_option("i", "max number of iterations to determine Z[cp]", 1);
    parser.add_option("t", "tolerance in iterative determination of Z[cp]", 1);

    // parser.add_option("direct", "also calculate direct averages from the time series at the original temperatures without any reweighting");

    parser.add_option("non-iterative", "first do a non-iterative estimation of the density of states as in Fenwick, 2008");

    parser.add_option("cp-range", "Takes three arguments to determine the range of control parameters to reweight to: the minimum, the maximum and the step size", 3);
    parser.add_option("cp-auto-range", "Takes one argument to determine the control parameter to reweight to: the step size; minimum and maximum are determinded automatically", 1);    
    parser.add_option("j", "use jack-knife error estimation, indicate number of blocks", 1);

    parser.add_option("sub-sample", "Sub samples the time series as they are read in (pass number of data points to be put into one sample", 1);
    parser.add_option("d", "Discard the first samples of the time series (pass number of samples to be left out) -- allows for further thermalization.", 1);
    parser.add_option("sort", "Sort replica timeseries by temperatures before doing any processing (simulate canonical data). This could hide correlations.");

    parser.add_option("global-tau", "Do not estimate statistical inefficiencies for individual bins, but only globally for each temperature -- g_km = g_k");
    parser.add_option("no-tau", "Ignore all differences in statistical inefficiencies when reweighting -- g_km = 1");

    parser.add_option("time-series-format", "Set to number of columns: 1 (default) or 2; 1-column time series are already sorted by control parameter", 1);

    parser.add_option("outputDirectory", "directory to write reweighting results to", 1);

    //further general arguments: file names of energy/observable time series [for any bc, but should be in separate directories for each bc]
    parser.parse(argc, argv);

    //echo whole commandline:
    cout << "command line: ";
    for (int arg = 0; arg < argc; ++arg) {
        cout << argv[arg] << " ";
    }
    cout << endl;

    const char* one_time_opts[] = {"info-pbc", "info-apbc-x", "info-apbc-y", "info-apbc-xy", "b", "cp-range", "cp-auto-range", "j", "i", "sub-sample", "sort", "time-series-format", "outputDirectory"};
    parser.check_one_time_options(one_time_opts);
    const char* incompatible1[] = {"global-tau", "no-tau"};
    parser.check_incompatible_options(incompatible1);
    const char* incompatible4[] = {"cp-range", "cp-auto-range"};
    parser.check_incompatible_options(incompatible4);

    if (parser.option("help")) {
        cout << "Multihistogram reweighting for time series originating from parallel tempering or canonical simulations" << endl;
        cout << "This version is meant to average over different boundary conditions [pbc, apbc-x, apbc-y, apbc-xy] -- pass data from 4 parallel tempering simulations" << endl;
        cout << "Command line options understood:" << endl;
        parser.print_options(cout);
        cout << endl;
        return;
    }

    if (const clp::option_type& od = parser.option("outputDirectory")) {
        setOutputDirectory(od.argument().c_str());
    }

    if (const clp::option_type& jk = parser.option("j")) {
        setJackknife(true, fromString<unsigned>(jk.argument()));
    }

    be_quiet = parser.option("q");
    infoFilenamesBC[PBC] = parser.option("info-pbc").argument();
    infoFilenamesBC[APBCX]  = parser.option("info-apbc-x").argument();    
    infoFilenamesBC[APBCY]  = parser.option("info-apbc-y").argument();    
    infoFilenamesBC[APBCXY] = parser.option("info-apbc-xy").argument();    

    if (not parser.option("b")) {
        cerr << "energy bin count not specified (option -b)!" << endl;
    } else {
        binCount = dlib::sa = parser.option("b").argument();
    }

    // do_directEstimates = parser.option("direct");

    non_iterative = parser.option("non-iterative");
    maxIterations = (non_iterative ? 0 : 10000);            //if non-iterative estimation is attempted, by default don't do any iterations, else default to 10000
    if (parser.option("i")) {
        maxIterations = dlib::sa = parser.option("i").argument();
    }
    if (parser.option("t")) {
        iterationTolerance = dlib::sa = parser.option("t").argument();
    }

    if (const clp::option_type& ss = parser.option("sub-sample")) {
        subsampleHowMuch = dlib::sa = ss.argument();
    }

    if (const clp::option_type& dd = parser.option("d")) {
        discardSamples = dlib::sa = dd.argument();
    }

    sortByCp = parser.option("sort");

    globalTau = parser.option("global-tau");
    noTau = parser.option("no-tau");

    if (const clp::option_type& tsf_opt = parser.option("time-series-format")) {
        std::string tsf = tsf_opt.argument();
        if (tsf == "1") {
            timeSeriesFormat = COL1;
        } else if (tsf == "2") {
            timeSeriesFormat = COL2;
        } else {
            cerr << "Invalid time series format -- should be \"1\" or \"2\"" << endl;
        }
    }
    
    initBC();

    if (const clp::option_type& rr = parser.option("cp-range")) {
        double cpMin = dlib::sa = rr.argument(0);
        double cpMax = dlib::sa = rr.argument(1);
        double cpStep = dlib::sa = rr.argument(2);
        reweightRangeBC(cpMin, cpMax, cpStep);
    }

    if (const clp::option_type& rr = parser.option("cp-auto-range")) {
        // double cpMin = dlib::sa = rr.argument(0);
        // double cpMax = dlib::sa = rr.argument(1);
        auto cpMinMax = std::minmax_element(mrbc[PBC]->controlParameterValues.begin(),
                                            mrbc[PBC]->controlParameterValues.end());
        double cpMin = *cpMinMax.first;
        double cpMax = *cpMinMax.second;
        double cpStep = dlib::sa = rr.argument(0);
        reweightRangeBC(cpMin, cpMax, cpStep);
    }    
}


template<class ProvideObservableMoments_bc_cp>
void handleObservableMomentsBC(ProvideObservableMoments_bc_cp callable, double cp) {
    std::array<ReweightedMomentsJK, 4> moments_bc;        
    // for (BC bc: all_BC) {
    //     moments[bc] = mrbc[bc]->reweightObservableMoments(cp);
    // }
    for (BC bc: all_BC) {
        moments_bc[bc] = callable(bc, cp);
    }

    ReweightedMomentsJK moments_averaged;
    for (BC bc: all_BC) {
        moments_averaged.o  += moments_bc[bc].o;
        moments_averaged.o2 += moments_bc[bc].o2;
        moments_averaged.o4 += moments_bc[bc].o4;
    }
    moments_averaged.o  /= 4.0;
    moments_averaged.o2 /= 4.0;
    moments_averaged.o4 /= 4.0;
        
    if (use_jackknife) {
        moments_averaged.jkBlocks_o.resize (jackknifeBlocks, 0.0);
        moments_averaged.jkBlocks_o2.resize(jackknifeBlocks, 0.0);
        moments_averaged.jkBlocks_o4.resize(jackknifeBlocks, 0.0);
            
        for (unsigned b = 0; b < jackknifeBlocks; ++b) {
            for (BC bc: all_BC) {
                moments_averaged.jkBlocks_o[b]  += moments_bc[bc].jkBlocks_o[b];
                moments_averaged.jkBlocks_o2[b] += moments_bc[bc].jkBlocks_o2[b];
                moments_averaged.jkBlocks_o4[b] += moments_bc[bc].jkBlocks_o4[b];
            }
            moments_averaged.jkBlocks_o[b]  /= 4.0;
            moments_averaged.jkBlocks_o2[b] /= 4.0;
            moments_averaged.jkBlocks_o4[b] /= 4.0;
        }
            
        // estimate quantities, also non-linear combinations of expectation values:
        jackknife((*observable)[cp], (*observableError)[cp], moments_averaged.jkBlocks_o);
        jackknife((*observableSquared)[cp], (*observableSquaredError)[cp], moments_averaged.jkBlocks_o2);
        (*observableSquared)[cp] *= mrbc[PBC]->systemSize; // so it's really a susceptibility
        (*observableSquaredError)[cp] *= mrbc[PBC]->systemSize;
            
        std::vector<double> jkBlocks_binderRatio(jackknifeBlocks, 0.0);
        std::vector<double> jkBlocks_susceptibility(jackknifeBlocks, 0.0);            
        for (unsigned b = 0; b < jackknifeBlocks; ++b) {
            jkBlocks_binderRatio[b] = moments_averaged.jkBlocks_o4[b] / std::pow(moments_averaged.jkBlocks_o2[b], 2);
            jkBlocks_susceptibility[b] = mrbc[PBC]->systemSize * (moments_averaged.jkBlocks_o2[b] -
                                                                  pow(moments_averaged.jkBlocks_o[b], 2));
        }
            
        jackknife((*binderRatio)[cp], (*binderRatioError)[cp], jkBlocks_binderRatio);
        jackknife((*susceptibility)[cp], (*susceptibilityError)[cp], jkBlocks_susceptibility);            
            
    } else {
        (*observable)[cp] = moments_averaged.o;
        (*observableSquared)[cp] = mrbc[PBC]->systemSize * moments_averaged.o2;        // so it's really a susceptibility
        (*binderRatio)[cp] = moments_averaged.o4 / std::pow(moments_averaged.o2, 2);
        (*susceptibility)[cp] = mrbc[PBC]->systemSize * (moments_averaged.o2 -
                                                         pow(moments_averaged.o, 2));
    }
}

void reweightBC(double cp) {
    handleObservableMomentsBC( [&](BC bc, double cp) -> ReweightedMomentsJK {
            return mrbc[bc]->reweightObservableMoments(cp);
        }, cp);
    writeOutResults();
}

void reweightRangeBC(double cpMin, double cpMax, double cpStep) {
    for (double cp = cpMin; cp <= cpMax; cp += cpStep) {
        handleObservableMomentsBC( [&](BC bc, double cp) -> ReweightedMomentsJK {
                return mrbc[bc]->reweightObservableMoments(cp);
            }, cp);
    }
    writeOutResults();
}

// void directResultsBC() {
// }
