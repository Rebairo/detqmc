/*
 * deteval.cpp
 *
 *  Created on: Apr 29, 2013
 *      Author: gerlach
 */

// Evaluate time series generated by detqmc.
// Call in directory containing timeseries files.

#include <iostream>
#include <algorithm>
#include <iterator>
#include <memory>
#include <map>
#include <cmath>
#include <vector>
#include <string>
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wshadow"
#include "boost/program_options.hpp"
#pragma GCC diagnostic pop
#include "git-revision.h"
#include "tools.h"                      //glob
#include "dataseriesloader.h"
#include "datamapwriter.h"
#include "metadata.h"
#include "exceptions.h"
#include "statistics.h"

int main(int argc, char **argv) {
    uint32_t discard = 0;
    uint32_t subsample = 1;
    uint32_t jkBlocks = 1;
    bool notau = false;
    bool noexp = false;

    //parse command line options
    namespace po = boost::program_options;
    po::options_description evalOptions("Time series evaluation options");
    evalOptions.add_options()
            ("help", "print help on allowed options and exit")
            ("version,v", "print version information (git hash, build date) and exit")
            ("discard,d", po::value<uint32_t>(&discard)->default_value(0),
                    "number of initial time series entries to discard (additional thermalization)")
            ("subsample,s", po::value<uint32_t>(&subsample)->default_value(1),
                    "take only every s'th sample into account")
            ("jkblocks,j", po::value<uint32_t>(&jkBlocks)->default_value(1),
                    "number of jackknife blocks to use")
            ("notau", po::bool_switch(&notau)->default_value(false),
                    "switch of estimation of integrated autocorrelation times")
            ("noexp", po::bool_switch(&noexp)->default_value(false),
                    "switch of estimation of expectation values and errorbars")
            ;
    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, evalOptions), vm);
    po::notify(vm);
    bool earlyExit = false;
    if (vm.count("help")) {
        std::cout << "Evaluate time series generated by detqmc.  Call in directory containing timeseries files.\n"
                  << "Will write results to files eval-results.values and eval-tauint.values\n\n"
                  << evalOptions << std::endl;
        earlyExit = true;
    }
    if (vm.count("version")) {
        std::cout << "Build info:\n"
                  << metadataToString(collectVersionInfo())
                  << std::endl;
        earlyExit = true;
    }
    if (earlyExit) {
        return 0;
    }

    //take simulation metadata from file info.dat, remove some unnecessary parts
    MetadataMap meta = readOnlyMetadata("info.dat");
    std::string keys[] = {"buildDate", "buildHost", "buildTime",
            "cppflags", "cxxflags", "gitBranch", "gitRevisionHash",
            "sweepsDone", "sweepsDoneThermalization", "totalWallTimeSecs"};
    for ( std::string key : keys) {
        if (meta.count(key)) {
            meta.erase(key);
        }
    }
    uint32_t guessedLength = static_cast<uint32_t>(fromString<double>(meta.at("sweeps")) /
            fromString<double>(meta.at("measureInterval")));

    //Store averages / nonlinear estimates, jackknife errors,
    //integrated autocorrelation times here
    //key: observable name
    typedef std::map<std::string, double> ObsValMap;
    ObsValMap estimates, errors, tauints;
    //jackknife-block wise estimates
    typedef std::map<std::string, std::vector<double>> ObsVecMap;
    ObsVecMap jkBlockEstimates;

    uint32_t evalSamples = 0;

    //metadata necessary for the computation of the susceptibility
    // spatial system size, and number of imaginary time slices
    uint32_t L = fromString<uint32_t>(meta.at("L"));
    uint32_t N = L*L;
    uint32_t m = fromString<uint32_t>(meta.at("m"));
    double dtau = fromString<double>(meta.at("dtau"));

    //process time series files
    std::vector<std::string> filenames = glob("*.series");
    for (std::string fn : filenames) {
        std::cout << "Processing " << fn << ", ";
        DoubleSeriesLoader reader;
        reader.readFromFile(fn, subsample, discard, guessedLength);
        if (reader.getColumns() != 1) {
            throw GeneralError("File " + fn + " does not have exactly 1 column");
        }

        std::vector<double>* data = reader.getData();       //TODO: smart pointers!
        std::string obsName;
        reader.getMeta("observable", obsName);
        std::cout << "observable: " << obsName << "..." << std::flush;

        if (not noexp) {
            estimates[obsName] = average(*data);
            jkBlockEstimates[obsName] = jackknifeBlockEstimates(*data, jkBlocks);
            // //this below is not what we want
            // if (obsName == "normPhi") {
            //     using std::pow;
            //     estimates["normPhiSquared"] = average<double>( [](double v) { return pow(v, 2); }, *data);
            //     jkBlockEstimates["normPhiSquared"] = jackknifeBlockEstimates<double>(
            //             [](double v) { return pow(v, 2); },
            //             *data, jkBlocks );
            //     estimates["normPhiFourth"] = average<double>( [](double v) { return pow(v, 4); }, *data);
            //     jkBlockEstimates["normPhiFourth"] = jackknifeBlockEstimates<double>(
            //             [](double v) { return pow(v, 4); },
            //             *data, jkBlocks );
            //     estimates["normPhiBinder"] = 1.0 - (3.0*estimates["normPhiFourth"]) /
            //             (5.0*pow(estimates["normPhiSquared"], 2));
            //     jkBlockEstimates["normPhiBinder"] = std::vector<double>(jkBlocks, 0);
            //     for (uint32_t jb = 0; jb < jkBlocks; ++jb) {
            //         jkBlockEstimates["normPhiBinder"][jb] =
            //                 1.0 - (3.0*jkBlockEstimates["normPhiFourth"][jb]) /
            //                 (5.0*pow(jkBlockEstimates["normPhiSquared"][jb], 2));
            //     }
            // }

            // compute Binder cumulant and susceptibility (connected,
            // i.e. with the disconnected part substracted), 
            // the suscseptibility *without* the subtracted part:
            //   normMeanPhiSquared
            if (obsName == "normMeanPhi") {
                using std::pow;
                estimates["normMeanPhiSquared"] = average<double>(
                    [](double v) { return pow(v, 2); },
                    *data );
                jkBlockEstimates["normMeanPhiSquared"] = jackknifeBlockEstimates<double>(
                    [](double v) { return pow(v, 2); },
                    *data, jkBlocks );
                
                estimates["normMeanPhiFourth"] = average<double>(
                    [](double v) { return pow(v, 4); },
                    *data );
                jkBlockEstimates["normMeanPhiFourth"] = jackknifeBlockEstimates<double>(
                    [](double v) { return pow(v, 4); },
                    *data, jkBlocks );
                
                estimates["phiBinder"] = 1.0 - (3.0*estimates["normMeanPhiFourth"]) /
                    (5.0*pow(estimates["normMeanPhiSquared"], 2));
                jkBlockEstimates["phiBinder"] = std::vector<double>(jkBlocks, 0);
                for (uint32_t jb = 0; jb < jkBlocks; ++jb) {
                    jkBlockEstimates["phiBinder"][jb] =
                        1.0 - (3.0*jkBlockEstimates["normMeanPhiFourth"][jb]) /
                        (5.0*pow(jkBlockEstimates["normMeanPhiSquared"][jb], 2));
                }

                estimates["phiSusceptibility"] = (dtau * m * N) * (
                    estimates["normMeanPhiSquared"] -
                    pow(estimates["normMeanPhi"], 2)
                    );
                jkBlockEstimates["phiSusceptibility"] = std::vector<double>(jkBlocks, 0);
                for (uint32_t jb = 0; jb < jkBlocks; ++jb) {
                    jkBlockEstimates["phiSusceptibility"][jb] = (dtau * m * N) * (
                        jkBlockEstimates["normMeanPhiSquared"][jb] -
                        pow(jkBlockEstimates["normMeanPhi"][jb], 2)
                        );
                }
                
            }
        }
//      std::copy(std::begin(jkBlockEstimates[obsName]), std::end(jkBlockEstimates[obsName]), std::ostream_iterator<double>(std::cout, " "));
//      std::cout << std::endl;
//      std::cout << average(jkBlockEstimates[obsName]);

        if (not notau) {
            tauints[obsName] = tauint(*data);
        }

        evalSamples = static_cast<uint32_t>(data->size());

        reader.deleteData();

        std::cout << std::endl;
    }

    //calculate error bars from jackknife block estimates
    if (not noexp and jkBlocks > 1) {
        for (auto const& nameBlockPair : jkBlockEstimates) {
            const std::string obsName = nameBlockPair.first;
            const std::vector<double> blockEstimates = nameBlockPair.second;
            errors[obsName] = jackknife(blockEstimates, estimates[obsName]);
        }
    }

    if (not noexp) {
        StringDoubleMapWriter resultsWriter;
        resultsWriter.addMetadataMap(meta);
        resultsWriter.addMeta("eval-jackknife-blocks", jkBlocks);
        resultsWriter.addMeta("eval-discard", discard);
        resultsWriter.addMeta("eval-subsample", subsample);
        resultsWriter.addMeta("eval-samples", evalSamples);
        if (jkBlocks > 1) {
            resultsWriter.addHeaderText("Averages and jackknife error bars computed from time series");
            resultsWriter.setData(std::make_shared<ObsValMap>(estimates));
            resultsWriter.setErrors(std::make_shared<ObsValMap>(errors));
        } else {
            resultsWriter.addHeaderText("Averages computed from time series");
            resultsWriter.setData(std::make_shared<ObsValMap>(estimates));
        }
        resultsWriter.writeToFile("eval-results.values");
    }

    if (not notau) {
        StringDoubleMapWriter tauintWriter;
        tauintWriter.addMetadataMap(meta);
        tauintWriter.addMeta("eval-discard", discard);
        tauintWriter.addMeta("eval-subsample", subsample);
        tauintWriter.addMeta("eval-samples", evalSamples);
        tauintWriter.addHeaderText("Tauint estimates computed from time series");
        tauintWriter.setData(std::make_shared<ObsValMap>(tauints));
        tauintWriter.writeToFile("eval-tauint.values");
    }

    std::cout << "Done!" << std::endl;

    return 0;
}
